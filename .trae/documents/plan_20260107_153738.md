# AI视频换脸应用 - gRPC视频传输实现计划

## 1. 技术栈选择

### 1.1 后端
- **框架**：Python + FastAPI + gRPC
- **gRPC库**：grpcio, grpcio-tools
- **Protocol Buffers**：protobuf
- **文件处理**：Pillow, FFmpeg-python

### 1.2 前端
- **框架**：Flutter
- **gRPC库**：grpc, protobuf
- **生成工具**：protoc + dart-grpc-plugin

## 2. gRPC服务定义

### 2.1 服务和消息定义

创建`proto/video_service.proto`文件：

```protobuf
syntax = "proto3";

package video;

// 视频上传请求消息
message UploadRequest {
  string user_id = 1;
  string file_name = 2;
  bytes chunk = 3;
  int32 chunk_index = 4;
  int32 total_chunks = 5;
  string file_type = 6; // image/video
}

// 视频上传响应消息
message UploadResponse {
  string status = 1;
  string message = 2;
  string file_url = 3;
  int32 uploaded_chunks = 4;
  int32 total_chunks = 5;
}

// 任务创建请求消息
message CreateTaskRequest {
  string user_id = 1;
  string image_url = 2;
  string video_url = 3;
}

// 任务响应消息
message TaskResponse {
  string task_id = 1;
  string status = 2; // pending, processing, completed, failed
  int32 progress = 3;
  string result_url = 4;
  string error_message = 5;
}

// 任务状态查询请求
message TaskStatusRequest {
  string task_id = 1;
}

// 视频服务定义
service VideoService {
  // 流式上传视频
  rpc UploadVideo(stream UploadRequest) returns (UploadResponse);
  
  // 创建换脸任务
  rpc CreateTask(CreateTaskRequest) returns (TaskResponse);
  
  // 获取任务状态
  rpc GetTaskStatus(TaskStatusRequest) returns (TaskResponse);
}
```

## 3. 后端实现

### 3.1 项目结构
```
backend/
├── proto/
│   └── video_service.proto
├── server/
│   ├── main.py
│   ├── video_service.py
│   ├── models/
│   │   ├── user.py
│   │   └── task.py
│   └── utils/
│       ├── file_processor.py
│       └── mock_ai.py
├── uploads/
└── outputs/
```

### 3.2 生成gRPC代码
```bash
# 安装依赖
pip install grpcio grpcio-tools protobuf

# 生成Python代码
python -m grpc_tools.protoc \
  -I../proto \
  --python_out=. \
  --grpc_python_out=. \
  ../proto/video_service.proto
```

### 3.3 实现gRPC服务

#### 3.3.1 核心服务逻辑
```python
# video_service.py
import grpc
from concurrent import futures
from proto import video_service_pb2, video_service_pb2_grpc

class VideoService(video_service_pb2_grpc.VideoServiceServicer):
    def UploadVideo(self, request_iterator, context):
        # 处理流式上传
        file_path = ""
        uploaded_chunks = 0
        total_chunks = 0
        
        for request in request_iterator:
            # 初始化文件路径和总块数
            if not file_path:
                total_chunks = request.total_chunks
                file_path = self._get_file_path(request.file_name)
                
            # 写入分片
            self._write_chunk(file_path, request.chunk, request.chunk_index)
            uploaded_chunks += 1
            
            # 返回上传进度
            yield video_service_pb2.UploadResponse(
                status="uploading",
                uploaded_chunks=uploaded_chunks,
                total_chunks=total_chunks
            )
        
        # 上传完成，返回结果
        file_url = f"/uploads/{request.file_name}"
        return video_service_pb2.UploadResponse(
            status="completed",
            message="Upload successful",
            file_url=file_url,
            uploaded_chunks=uploaded_chunks,
            total_chunks=total_chunks
        )
    
    def CreateTask(self, request, context):
        # 创建换脸任务
        task_id = self._generate_task_id()
        # 存储任务到数据库
        # 启动异步处理
        return video_service_pb2.TaskResponse(
            task_id=task_id,
            status="pending",
            progress=0
        )
    
    def GetTaskStatus(self, request, context):
        # 获取任务状态
        task = self._get_task(request.task_id)
        return video_service_pb2.TaskResponse(
            task_id=task.id,
            status=task.status,
            progress=task.progress,
            result_url=task.result_url,
            error_message=task.error_message
        )
    
    # 辅助方法
    def _get_file_path(self, filename):
        # 生成文件存储路径
        pass
    
    def _write_chunk(self, file_path, chunk, chunk_index):
        # 写入分片到文件
        pass
    
    def _generate_task_id(self):
        # 生成唯一任务ID
        pass
    
    def _get_task(self, task_id):
        # 从数据库获取任务
        pass
```

#### 3.3.2 启动gRPC服务器

```python
# main.py
import grpc
from concurrent import futures
from proto import video_service_pb2_grpc
from video_service import VideoService

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    video_service_pb2_grpc.add_VideoServiceServicer_to_server(VideoService(), server)
    server.add_insecure_port('[::]:50051')
    server.start()
    print("gRPC server running on port 50051")
    server.wait_for_termination()

if __name__ == "__main__":
    serve()
```

## 4. 前端实现

### 4.1 生成gRPC客户端代码

```bash
# 安装生成工具
dart pub global activate protoc_plugin

# 生成Dart代码
protoc -I=../proto \
  --dart_out=grpc:lib/grpc \
  --plugin=protoc-gen-dart=/path/to/protoc-gen-dart \
  ../proto/video_service.proto
```

### 4.2 gRPC客户端实现

创建`lib/grpc/video_client.dart`：

```dart
import 'package:grpc/grpc.dart';
import 'lib/grpc/video_service.pbgrpc.dart';

class VideoClient {
  late VideoServiceClient _client;
  
  VideoClient() {
    final channel = ClientChannel(
      'localhost',
      port: 50051,
      options: ChannelOptions(
        credentials: ChannelCredentials.insecure(),
      ),
    );
    _client = VideoServiceClient(channel);
  }
  
  // 上传视频方法
  Stream<UploadResponse> uploadVideo(
    String userId,
    String fileName,
    List<int> fileBytes,
    String fileType,
  ) async* {
    // 分片大小：10MB
    const int chunkSize = 10 * 1024 * 1024;
    final int totalChunks = (fileBytes.length / chunkSize).ceil();
    
    // 创建请求流
    final requestStream = Stream<UploadRequest>.fromIterable(
      [
        for (int i = 0; i < totalChunks; i++)
          UploadRequest()
            ..userId = userId
            ..fileName = fileName
            ..chunk = fileBytes.sublist(
              i * chunkSize,
              (i + 1) * chunkSize > fileBytes.length
                  ? fileBytes.length
                  : (i + 1) * chunkSize,
            )
            ..chunkIndex = i
            ..totalChunks = totalChunks
            ..fileType = fileType,
      ],
    );
    
    // 调用gRPC服务
    final response = await _client.uploadVideo(requestStream);
    yield response;
  }
  
  // 创建任务方法
  Future<TaskResponse> createTask(
    String userId,
    String imageUrl,
    String videoUrl,
  ) async {
    final request = CreateTaskRequest()
      ..userId = userId
      ..imageUrl = imageUrl
      ..videoUrl = videoUrl;
    
    return await _client.createTask(request);
  }
  
  // 获取任务状态
  Future<TaskResponse> getTaskStatus(String taskId) async {
    final request = GetTaskStatusRequest()..taskId = taskId;
    return await _client.getTaskStatus(request);
  }
}
```

### 4.3 集成到现有代码

修改`task_provider.dart`：

```dart
class TaskProvider with ChangeNotifier {
  // 添加gRPC客户端
  final VideoClient _videoClient = VideoClient();
  
  // 修改上传方法
  Future<Map<String, dynamic>> uploadFile(String filePath, String fileType) async {
    try {
      // 读取文件字节
      final file = File(filePath);
      final bytes = await file.readAsBytes();
      
      // 使用gRPC上传
      final userId = "test_user";
      final fileName = file.path.split('/').last;
      
      final responseStream = _videoClient.uploadVideo(
        userId,
        fileName,
        bytes,
        fileType,
      );
      
      // 处理响应流
      await for (final response in responseStream) {
        // 更新上传进度
        _currentProgress = 
            (response.uploadedChunks / response.totalChunks * 100).toInt();
        notifyListeners();
        
        if (response.status == "completed") {
          return {
            "fileUrl": response.fileUrl,
            "message": response.message
          };
        }
      }
      
      return {"error": "Upload failed"};
    } catch (e) {
      rethrow;
    }
  }
}
```

## 5. 实现步骤

### 5.1 后端实现步骤
1. **安装依赖**：
   ```bash
   pip install fastapi uvicorn grpcio grpcio-tools protobuf ffmpeg-python
   ```
2. **生成gRPC代码**：使用protoc生成Python代码
3. **实现gRPC服务**：创建VideoService类，实现所有方法
4. **添加Mock AI处理**：模拟人脸替换逻辑
5. **启动服务器**：启动gRPC服务器

### 5.2 前端实现步骤
1. **添加依赖**：
   ```yaml
dependencies:
  grpc: ^3.2.4
  protobuf: ^3.1.0
  ```
2. **生成gRPC代码**：使用protoc生成Dart代码
3. **实现gRPC客户端**：创建VideoClient类
4. **集成到现有代码**：修改TaskProvider，使用gRPC上传文件
5. **更新UI**：显示上传进度和状态

## 6. 测试方案

### 6.1 本地测试
1. **启动后端**：
   ```bash
   python main.py
   ```
2. **启动前端**：
   ```bash
   flutter run -d chrome
   ```
3. **测试流程**：
   - 上传图片和视频
   - 查看上传进度
   - 创建换脸任务
   - 查看任务状态
   - 获取处理结果

### 6.2 性能测试
- **大文件上传**：测试500MB视频上传
- **并发测试**：模拟3-5个并发上传
- **稳定性测试**：模拟网络波动和中断

## 7. 优势和注意事项

### 7.1 优势
- **高效传输**：基于HTTP/2，支持多路复用和流控
- **低延迟**：适合实时进度更新
- **类型安全**：使用Protocol Buffers，减少类型错误
- **可扩展性**：支持双向流和服务器流

### 7.2 注意事项
- **防火墙配置**：确保50051端口开放
- **跨域问题**：gRPC基于HTTP/2，无需额外CORS配置
- **错误处理**：实现完整的错误处理机制
- **资源管理**：合理设置线程池大小和超时时间

## 8. 后续优化

1. **添加认证**：使用gRPC拦截器实现认证
2. **加密传输**：使用TLS加密gRPC连接
3. **断点续传**：实现分片状态记录和恢复
4. **负载均衡**：添加gRPC负载均衡支持
5. **监控告警**：添加监控和告警机制

## 9. 实现复杂度评估

| 实现阶段 | 预计时间 | 主要工作 |
|---------|---------|----------|
| 服务定义 | 1天 | 定义gRPC服务和消息 |
| 后端实现 | 2天 | 实现gRPC服务和Mock AI |
| 前端实现 | 2天 | 生成客户端代码和集成 |
| 测试调试 | 1天 | 本地测试和性能优化 |

**总预计时间**：6天

## 10. 资源要求

### 10.1 硬件要求
- **CPU**：4核以上
- **内存**：8GB以上
- **存储**：100GB以上SSD
- **网络**：稳定的本地网络

### 10.2 软件要求
- **Python**：3.8+
- **Flutter**：3.0+
- **Protocol Buffers**：3.19+
- **FFmpeg**：4.0+

通过以上计划，您可以在本地实现一个基于gRPC的AI视频换脸应用，支持高效的视频传输和处理。